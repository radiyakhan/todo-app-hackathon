# Data Model: Authentication & User Context

**Feature**: 002-auth-jwt
**Date**: 2026-02-08
**Purpose**: Define data entities and relationships for authentication system

## Entities

### User

**Purpose**: Represents a registered user account with authentication credentials.

**Attributes**:
- `id` (string, primary key): Unique user identifier (UUID generated by Better Auth)
- `email` (string, unique, not null): User's email address for authentication
- `password_hash` (string, not null): Bcrypt-hashed password (never store plain text)
- `name` (string, nullable): User's display name
- `created_at` (timestamp, not null): Account creation timestamp
- `updated_at` (timestamp, not null): Last account update timestamp

**Validation Rules**:
- Email must be valid format (RFC 5322)
- Email must be unique across all users
- Password must be at least 8 characters (enforced by Better Auth)
- Password hash uses bcrypt with cost factor 12

**State Transitions**:
- Created → Active (on successful signup)
- Active → Active (on password change, profile update)

**Relationships**:
- One User has many Tasks (one-to-many)

**Indexes**:
- Primary key on `id`
- Unique index on `email` (for login lookup)
- Index on `created_at` (for analytics)

**Security Considerations**:
- Password never stored in plain text
- Password hash never exposed in API responses
- Email used for authentication but not as primary key (allows email changes)

---

### Task (Modified)

**Purpose**: Represents a todo item belonging to a specific user.

**Attributes**:
- `id` (integer, primary key): Unique task identifier (auto-increment)
- `user_id` (string, foreign key, not null): Owner of the task (references User.id)
- `title` (string, not null): Task title (max 200 characters)
- `description` (string, nullable): Task description (max 1000 characters)
- `completed` (boolean, not null, default false): Task completion status
- `created_at` (timestamp, not null): Task creation timestamp
- `updated_at` (timestamp, not null): Last task update timestamp

**Validation Rules**:
- Title must be 1-200 characters
- Description must be 0-1000 characters
- user_id must reference existing User
- completed must be boolean

**State Transitions**:
- Created → Active (completed=false)
- Active → Completed (completed=true)
- Completed → Active (completed=false, toggle back)
- Any state → Deleted (soft or hard delete)

**Relationships**:
- Many Tasks belong to one User (many-to-one)

**Indexes**:
- Primary key on `id`
- Foreign key index on `user_id` (for filtering by user)
- Composite index on `(user_id, completed)` (for filtered queries)
- Index on `created_at` (for sorting)

**Security Considerations**:
- All queries MUST filter by user_id
- user_id MUST match authenticated user from JWT
- No task can be accessed without valid authentication

---

## Entity Relationships

```
User (1) ----< (many) Task

User:
- id (PK)
- email (unique)
- password_hash
- name
- created_at
- updated_at

Task:
- id (PK)
- user_id (FK → User.id)
- title
- description
- completed
- created_at
- updated_at
```

---

## Database Schema Changes

### New Table: users

```sql
CREATE TABLE users (
    id VARCHAR(255) PRIMARY KEY,
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    name VARCHAR(255),
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE UNIQUE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_created_at ON users(created_at);
```

### Modified Table: tasks

**Note**: The tasks table already exists from Phase I (backend-task-api). We need to verify it has the user_id column and proper indexes.

**Expected Schema**:
```sql
CREATE TABLE tasks (
    id SERIAL PRIMARY KEY,
    user_id VARCHAR(255) NOT NULL,
    title VARCHAR(200) NOT NULL,
    description VARCHAR(1000),
    completed BOOLEAN NOT NULL DEFAULT FALSE,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);

CREATE INDEX idx_tasks_user_id ON tasks(user_id);
CREATE INDEX idx_tasks_user_completed ON tasks(user_id, completed);
CREATE INDEX idx_tasks_created_at ON tasks(created_at);
```

**Migration Required**:
- Add foreign key constraint from tasks.user_id to users.id
- Verify indexes exist on user_id and (user_id, completed)
- Add ON DELETE CASCADE to clean up tasks when user deleted

---

## Data Access Patterns

### Authentication Patterns

**User Signup**:
```
1. Validate email format and uniqueness
2. Hash password with bcrypt
3. Generate unique user_id (UUID)
4. Insert user record
5. Return user_id and email (not password_hash)
```

**User Signin**:
```
1. Look up user by email
2. Verify password against stored hash
3. Generate JWT token with user_id
4. Return token in httpOnly cookie
```

**Token Verification**:
```
1. Extract token from Authorization header or cookie
2. Verify signature using shared secret
3. Check expiration timestamp
4. Extract user_id from payload
5. Return user_id for authorization
```

### Task Access Patterns

**List User's Tasks**:
```sql
SELECT * FROM tasks
WHERE user_id = :authenticated_user_id
ORDER BY created_at DESC;
```

**Get Specific Task**:
```sql
SELECT * FROM tasks
WHERE id = :task_id AND user_id = :authenticated_user_id;
```

**Create Task**:
```sql
INSERT INTO tasks (user_id, title, description, completed, created_at, updated_at)
VALUES (:authenticated_user_id, :title, :description, false, NOW(), NOW())
RETURNING *;
```

**Update Task**:
```sql
UPDATE tasks
SET title = :title, description = :description, updated_at = NOW()
WHERE id = :task_id AND user_id = :authenticated_user_id
RETURNING *;
```

**Delete Task**:
```sql
DELETE FROM tasks
WHERE id = :task_id AND user_id = :authenticated_user_id;
```

**Toggle Task Completion**:
```sql
UPDATE tasks
SET completed = NOT completed, updated_at = NOW()
WHERE id = :task_id AND user_id = :authenticated_user_id
RETURNING *;
```

---

## Data Validation

### User Entity Validation

**Email Validation**:
- Format: RFC 5322 compliant
- Uniqueness: Case-insensitive check
- Length: 5-255 characters
- Example valid: user@example.com
- Example invalid: user@, @example.com, user

**Password Validation**:
- Minimum length: 8 characters (Better Auth default)
- Maximum length: 128 characters (bcrypt limit)
- No complexity requirements (out of scope)
- Hashed before storage (never store plain text)

**Name Validation**:
- Optional field
- Length: 1-255 characters if provided
- No special character restrictions

### Task Entity Validation

**Title Validation**:
- Required field
- Length: 1-200 characters
- No HTML or script tags (XSS prevention)

**Description Validation**:
- Optional field
- Length: 0-1000 characters if provided
- No HTML or script tags (XSS prevention)

**User ID Validation**:
- Required field
- Must match authenticated user from JWT
- Must reference existing user in database

---

## Performance Considerations

### Query Optimization

**Indexed Queries**:
- User lookup by email: O(log n) with unique index
- Task filtering by user_id: O(log n) with index
- Task filtering by user_id and completed: O(log n) with composite index

**Expected Query Patterns**:
- Most common: List tasks for user (filtered by user_id)
- Second most common: Get specific task (filtered by id and user_id)
- Less common: User authentication (lookup by email)

**Connection Pooling**:
- Backend uses connection pool (pool_size=5, max_overflow=10)
- Neon Serverless PostgreSQL handles connection scaling
- Stateless backend enables horizontal scaling

### Data Volume Estimates

**Users**:
- Expected: 10-1000 users (hackathon scope)
- Growth: Linear with user signups
- Storage: ~500 bytes per user record

**Tasks**:
- Expected: 10-100 tasks per user
- Growth: Linear with user activity
- Storage: ~300 bytes per task record

**Total Storage**:
- 1000 users × 500 bytes = 500 KB
- 1000 users × 50 tasks × 300 bytes = 15 MB
- Total: ~15.5 MB (well within Neon free tier)

---

## Security Constraints

### Data Isolation

**Enforcement Layers**:
1. **JWT Middleware**: Extracts authenticated user_id
2. **Route Handler**: Verifies URL user_id matches authenticated user_id
3. **Service Layer**: Filters all queries by authenticated user_id
4. **Database Layer**: Foreign key constraints ensure referential integrity

**Forbidden Operations**:
- ❌ Query tasks without user_id filter
- ❌ Access tasks where user_id ≠ authenticated user_id
- ❌ Modify user_id of existing task
- ❌ Create task with different user_id than authenticated user

### Sensitive Data Protection

**Never Expose**:
- Password hashes in API responses
- JWT secret in logs or errors
- Other users' email addresses
- Other users' task data

**Always Validate**:
- JWT signature before trusting user_id
- User_id match between JWT and URL
- User_id match between JWT and database query

---

## Migration Strategy

### Phase 1: Create Users Table
```sql
-- Create users table
CREATE TABLE users (
    id VARCHAR(255) PRIMARY KEY,
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    name VARCHAR(255),
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- Create indexes
CREATE UNIQUE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_created_at ON users(created_at);
```

### Phase 2: Add Foreign Key to Tasks
```sql
-- Add foreign key constraint (if not exists)
ALTER TABLE tasks
ADD CONSTRAINT fk_tasks_user_id
FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE;

-- Verify indexes exist
CREATE INDEX IF NOT EXISTS idx_tasks_user_id ON tasks(user_id);
CREATE INDEX IF NOT EXISTS idx_tasks_user_completed ON tasks(user_id, completed);
```

### Phase 3: Verify Data Integrity
```sql
-- Check for orphaned tasks (tasks without valid user_id)
SELECT COUNT(*) FROM tasks
WHERE user_id NOT IN (SELECT id FROM users);

-- Should return 0 after migration
```

---

## Testing Data

### Test Users
```json
{
  "user1": {
    "email": "alice@example.com",
    "password": "password123",
    "name": "Alice"
  },
  "user2": {
    "email": "bob@example.com",
    "password": "password456",
    "name": "Bob"
  }
}
```

### Test Tasks
```json
{
  "alice_task1": {
    "user_id": "alice_uuid",
    "title": "Buy groceries",
    "description": "Milk, eggs, bread",
    "completed": false
  },
  "bob_task1": {
    "user_id": "bob_uuid",
    "title": "Finish project",
    "description": "Complete authentication feature",
    "completed": false
  }
}
```

### Test Scenarios
1. Alice signs up → creates task → signs out → signs in → sees her task
2. Bob signs up → creates task → cannot see Alice's task
3. Alice tries to access Bob's task by ID → receives 403 Forbidden
4. Unauthenticated user tries to list tasks → receives 401 Unauthorized
